---
import SectionTag from "../SectionTag.astro";
import SubSectionWithArrow from "../SubSectionWithArrow.astro";
---

<section id="core-concepts" class="scroll-mt-24 flex flex-col gap-6">
  <SectionTag>Big Idea</SectionTag>
  <h2 class="-mt-4 mb-4">Core Concepts</h2>

  <SubSectionWithArrow>
    <h3>Understanding the render cycle</h3>
    <p class="text-gray-600 mt-2">
      Glade's render cycle follows a predictable three-step process. First, there's{" "}
      <strong>request layout</strong>, where the system calculates dimensions and positions for all elements. Next comes{" "}
      <strong>pre-paint</strong>, where preparations are made for rendering (like setting up textures and GPU buffers). Finally,{" "}
      <strong>paint</strong> executes the actual drawing to the screen. This cycle runs at up to 120fps, ensuring smooth animations and interactions.
    </p>
  </SubSectionWithArrow>

  <SubSectionWithArrow>
    <h3>Component architecture and state</h3>
    <p class="text-gray-600 mt-2">
      All components in Glade have access to an app-level context, and updates are handled through a broadcast observer pattern. When you register an event handler—say, a click on a button or mouse movement—components automatically subscribe to relevant state changes. When those changes occur, subscribers are notified and re-render accordingly. Most of this is hidden from you as a developer. You just register your event handlers, mutate state at the component or app level, and Glade takes care of the rest.
    </p>
  </SubSectionWithArrow>

  <SubSectionWithArrow>
    <h3>Font rendering and embedding</h3>
    <p class="text-gray-600 mt-2">
      Glade currently embeds three fonts: Inter for sans-serif text, JetBrains Mono for monospace, and Noto Color Emoji for emoji rendering. The system first tries Inter or JetBrains Mono depending on your font family choice. If a character isn't available in those fonts (like an emoji), it falls back to Noto Color Emoji. This gives you clean, professional text with full emoji support.
    </p>
    <p class="text-gray-600">
      Because both fonts are currently embedded, WebAssembly builds are larger than ideal. I'm planning to add dynamic font loading in the future. For native builds, you'd continue embedding fonts (size is less of a concern, and local loading is faster). For browser deployments, you could fetch fonts asynchronously before starting your app, potentially using a smaller embedded font for an initial loading state.
    </p>
  </SubSectionWithArrow>
  <hr class="mt-10 bg-gray-300" />
</section>
